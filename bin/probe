#!/usr/bin/env bash
# probe - Probe URL with detailed timing and TLS info
# Performs HTTP request with timing, headers, and TLS certificate info

set -Eeuo pipefail
IFS=$'\n\t'

# Resolve symlinks to find the real script location
SCRIPT_SOURCE="${BASH_SOURCE[0]}"
while [ -L "$SCRIPT_SOURCE" ]; do
    SCRIPT_DIR="$(cd -P "$(dirname "$SCRIPT_SOURCE")" && pwd)"
    SCRIPT_SOURCE="$(readlink "$SCRIPT_SOURCE")"
    [[ $SCRIPT_SOURCE != /* ]] && SCRIPT_SOURCE="$SCRIPT_DIR/$SCRIPT_SOURCE"
done
SCRIPT_DIR="$(cd -P "$(dirname "$SCRIPT_SOURCE")" && pwd)"
# shellcheck source=../lib/common.sh
source "$SCRIPT_DIR/../lib/common.sh"

show_usage() {
    cat <<EOF
Usage: probe [options] <url>

Probe a URL with detailed timing, TLS info, and optional retries.

Arguments:
  <url>         URL to probe

Options:
  -r, --retries NUM    Number of retries (default: 3)
  -t, --timeout SEC    Timeout in seconds (default: 10)
  -v, --verbose        Show verbose output
  -h, --help          Show this help

Features:
  - HTTP timing breakdown (DNS, connect, TLS, transfer)
  - TLS certificate information
  - Response headers and status
  - Automatic retries with exponential backoff

Examples:
  probe https://example.com
  probe --retries 5 --timeout 30 https://api.example.com
  probe -v https://example.com/api/health
EOF
}

format_time() {
    local time_sec="$1"
    # Convert to milliseconds for better readability
    local time_ms=$(echo "$time_sec * 1000" | bc)
    printf "%.0f ms" "$time_ms"
}

format_size() {
    local bytes="$1"
    if [[ $bytes -lt 1024 ]]; then
        echo "${bytes} B"
    elif [[ $bytes -lt 1048576 ]]; then
        echo "$(echo "scale=1; $bytes / 1024" | bc) KB"
    else
        echo "$(echo "scale=1; $bytes / 1048576" | bc) MB"
    fi
}

get_status_indicator() {
    local code="$1"
    if [[ $code -ge 200 && $code -lt 300 ]]; then
        echo "‚úì"
    elif [[ $code -ge 300 && $code -lt 400 ]]; then
        echo "‚Üí"
    else
        echo "‚úó"
    fi
}

get_status_color() {
    local code="$1"
    if [[ $code -ge 200 && $code -lt 300 ]]; then
        echo "$GREEN"
    elif [[ $code -ge 300 && $code -lt 400 ]]; then
        echo "$YELLOW"
    else
        echo "$RED"
    fi
}

main() {
    local url=""
    local retries=3
    local timeout=10
    local verbose=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_usage
                exit 0
                ;;
            -r|--retries)
                retries="$2"
                shift 2
                ;;
            -t|--timeout)
                timeout="$2"
                shift 2
                ;;
            -v|--verbose)
                verbose=true
                shift
                ;;
            -*)
                log_error "Unknown option: $1"
                show_usage
                exit 1
                ;;
            *)
                url="$1"
                shift
                ;;
        esac
    done
    
    if [[ -z "$url" ]]; then
        log_error "URL required"
        show_usage
        exit 1
    fi
    
    need_cmd curl
    
    # Check for bc (for time formatting)
    if ! have_cmd bc; then
        log_warn "bc not found - timing will be shown in seconds"
    fi
    
    echo -e "${BOLD}=== Probing URL ===${NC}"
    echo -e "${CYAN}$url${NC}"
    echo ""
    
    # Create temp files
    local output headers timing
    output=$(mktemp)
    headers=$(mktemp)
    timing=$(mktemp)
    trap 'rm -f "$output" "$headers" "$timing" 2>/dev/null || true' EXIT
    
    local attempt=1
    local delay=2
    
    while [[ $attempt -le $retries ]]; do
        if [[ $attempt -gt 1 ]]; then
            log_info "Attempt $attempt/$retries..."
        fi
        
        # Perform curl with timing
        local curl_exit=0
        curl -w "%{json}" \
           --max-time "$timeout" \
           -s -S -L \
           -D "$headers" \
           -o "$output" \
           "$url" > "$timing" 2>&1 || curl_exit=$?
        
        if [[ $curl_exit -eq 0 ]]; then
            # Parse timing JSON
            local http_code dns_time connect_time tls_time transfer_time total_time size
            http_code=$(grep -o '"http_code":[0-9]*' "$timing" | cut -d: -f2 || echo "0")
            dns_time=$(grep -o '"time_namelookup":[0-9.]*' "$timing" | cut -d: -f2 || echo "0")
            connect_time=$(grep -o '"time_connect":[0-9.]*' "$timing" | cut -d: -f2 || echo "0")
            tls_time=$(grep -o '"time_appconnect":[0-9.]*' "$timing" | cut -d: -f2 || echo "0")
            transfer_time=$(grep -o '"time_starttransfer":[0-9.]*' "$timing" | cut -d: -f2 || echo "0")
            total_time=$(grep -o '"time_total":[0-9.]*' "$timing" | cut -d: -f2 || echo "0")
            size=$(grep -o '"size_download":[0-9]*' "$timing" | cut -d: -f2 || echo "0")
            
            # Display results
            local status_color=$(get_status_color "$http_code")
            local status_icon=$(get_status_indicator "$http_code")
            
            echo -e "${BOLD}${status_color}${status_icon} Response Status${NC}"
            echo -e "  HTTP ${BOLD}$http_code${NC} - $(format_size "$size")"
            echo ""
            
            echo -e "${BOLD}‚è±  Timing Breakdown${NC}"
            if have_cmd bc; then
                printf "  %-20s %s\n" "DNS Lookup:" "$(format_time "$dns_time")"
                printf "  %-20s %s\n" "TCP Connect:" "$(format_time "$connect_time")"
                if [[ "$url" =~ ^https:// ]] && [[ "$tls_time" != "0.000000" ]]; then
                    printf "  %-20s %s\n" "TLS Handshake:" "$(format_time "$tls_time")"
                fi
                printf "  %-20s %s\n" "Server Processing:" "$(format_time "$transfer_time")"
                printf "  ${BOLD}%-20s %s${NC}\n" "Total:" "$(format_time "$total_time")"
            else
                printf "  %-20s %.3fs\n" "DNS Lookup:" "$dns_time"
                printf "  %-20s %.3fs\n" "TCP Connect:" "$connect_time"
                if [[ "$url" =~ ^https:// ]] && [[ "$tls_time" != "0.000000" ]]; then
                    printf "  %-20s %.3fs\n" "TLS Handshake:" "$tls_time"
                fi
                printf "  %-20s %.3fs\n" "Server Processing:" "$transfer_time"
                printf "  ${BOLD}%-20s %.3fs${NC}\n" "Total:" "$total_time"
            fi
            echo ""
            
            # Show response headers (first few important ones)
            echo -e "${BOLD}üìã Response Headers${NC}"
            grep -E "^(HTTP/|Server:|Content-Type:|Content-Length:|Cache-Control:|Set-Cookie:)" "$headers" | head -10 || true
            echo ""
            
            # Show TLS info for HTTPS
            if [[ "$url" =~ ^https:// ]]; then
                echo -e "${BOLD}üîí TLS Certificate${NC}"
                local host
                host=$(echo "$url" | sed -E 's|^https://([^/:]+).*|\1|')
                local tls_info
                tls_info=$(timeout 5 openssl s_client -connect "${host}:443" -servername "$host" </dev/null 2>/dev/null | openssl x509 -noout -dates -subject -issuer 2>/dev/null || true)
                
                if [[ -n "$tls_info" ]]; then
                    echo "$tls_info" | while IFS= read -r line; do
                        if [[ "$line" =~ ^notBefore= ]]; then
                            echo "  Valid From:  ${line#notBefore=}"
                        elif [[ "$line" =~ ^notAfter= ]]; then
                            echo "  Valid Until: ${line#notAfter=}"
                        elif [[ "$line" =~ ^subject= ]]; then
                            echo "  Subject:     ${line#subject=}"
                        elif [[ "$line" =~ ^issuer= ]]; then
                            echo "  Issuer:      ${line#issuer=}"
                        fi
                    done
                else
                    log_warn "  Could not retrieve TLS certificate info"
                fi
                echo ""
            fi
            
            # Show response body if verbose
            if $verbose && [[ -s "$output" ]]; then
                echo -e "${BOLD}üìÑ Response Body${NC}"
                local body_size
                body_size=$(wc -c < "$output")
                if [[ $body_size -gt 1000 ]]; then
                    head -c 1000 "$output"
                    echo ""
                    echo -e "${CYAN}... (showing first 1000 of $body_size bytes)${NC}"
                else
                    cat "$output"
                fi
                echo ""
            fi
            
            # Summary
            echo -e "${BOLD}${GREEN}‚úì Success${NC}"
            if have_cmd bc; then
                echo -e "  Completed in $(format_time "$total_time")"
            else
                printf "  Completed in %.3fs\n" "$total_time"
            fi
            
            # Clean up and clear trap before returning
            rm -f "$output" "$headers" "$timing" 2>/dev/null || true
            trap - EXIT
            return 0
        fi
        
        if [[ $attempt -lt $retries ]]; then
            log_warn "Request failed. Retrying in ${delay}s..."
            sleep "$delay"
            delay=$((delay * 2))
        fi
        
        attempt=$((attempt + 1))
    done
    
    # Clean up and clear trap before dying
    rm -f "$output" "$headers" "$timing" 2>/dev/null || true
    trap - EXIT
    die "All $retries attempts failed"
}

main "$@"
